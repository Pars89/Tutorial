# Шпаргалка Git

## 1 Основы


### Операции с файлами

1. Создать файл - ```touch file.txt```

2. Открыть файл и распечатать содержимое - ```cat file.txt```

3. Копирование файла - ```copy file.txt src/```

4. Перемещение файла - ```mv file.txt src/```

5. Удалить файл - ```rm file.txt```


### Операции с директориями

1. Создать директорию - ```mkdir dir1```

2. Открыть директорию - ```cd dir1```

3. Удалить пустую директорию - ```rm dir1```

4. Удалить непустую директорию - ```rm -r dir1```


### Основные переходы в системе

1. Перейти в домашнюю директорию - ```cd ~```

2. Перейти в корневую директорию - ```cd c:/```

3. Перейти в родительскую директорию - ```cd ..```


### Часто используемые команды

1.1 Посмотреть список файлов в текущей директории - ```ls```

1.2 Посмотреть список скрытых файлов в текущей директории - ```ls -a```

2. Посмотреть текущую директорию - ```pwd```


## 2 Операции Git


### Настройка

1. Инициализация локального репозитория - ```git init```

2. Создание удаленного репозитория на GitHub:

2.1 В вкладке "Repositories" нажать на зеленую кнопку "New"

2.2 Написать имя репозитория под заголовком "Repository name" и нажать на кнпоку "Create repository"

3. Настройка SSH ключей при первой попытке связи локального и удаленного репозитория

4.1 Привязка удаленного репозитория к локальному -``` git remote add origin git@github.com:Pars89/Tutorial.git```

4.2 Проверка, успешного подклчючения - ```git remote -v```


### Операции для отправки коммита в локальный и удаленный репозиторий

1. Подготовка файлов к коммиту:

1.1 ```git add file.txt```

1.2 ```git add src/```

2. Закоммитили файлы - ```git commit -m "file.txt and src/ was added"```

3. Отправить файлы с локального репозитория на удаленный:

3.1 Если первый раз отправляете команду - ```git push -u origin master```

3.2 Загрузка с локального репозитория на GitHub, если больше 1, то - ```git push```

3.3 Когда возникает ошибка(разные структуры у репозиториев), принудительно загружаем -  ```git push -f```


### Часто используемые команды

1. Показывает, какие изменения были внесены  - ```git status```

2. Выводит историю коммитов - ```git log```

3. Выводит краткую историю коммитов при это хеш коммита сокращен - ```git log --oneline```


## 3 Полезная информация


### Информация о коммитах

1. Выводит информацию о коммитах - ```git log```

2. Сперва на экран выводится хеш коммита - это уникальный ID коммита

3. В заголовке HEAD хранится хеш последнего коммита

4. В заголовке "Author" - хранится информация, кто сделал коммит

5. В заголовке "Date" - хранится информация, когда был сделан коммит

6. И в последнюю очередь выводит - сообщение коммита


### Жизненный цикл файла

Файл может находится в 4 состояниях:

С помошью этой команды можно проверить состояние - ```git status```

1. untracked - не отслеживается Git

2. staged - индексируется Git (после команды ```Git add```) еще не включен в историю репозитория

3. tracked - отслеживается Git (после команды ```Git commit```) включен в историю репозитория

4. modified - после коммита файл был изменен


### Оформление сообщений к коммитам

1. В английском языке принято писать в императивном форме

2. На русском языке писать лучше всего в инфинитиве, но у разных компаний свои правила

3. Все коммиты должны быть информативны без лищней информацией


### Команды, позволяющие изменить уже отправленные коммиты

Перед тем как отправить файл, файл должен быть в состоянии 'staged'

1.1 Для отправки файла в последний коммит, не редактируя сообщение - ```git commit --amend --no-edit```

1.2 Для отправки файла в последний коммит, редактируя сообщение - ```git commit --amend -m "New message"```



## 4 Как откатиться назад, если «всё сломалось»


### Файл случайно оказался в состоянии staged

1. Изменить состояние файла из staged в untracked - ```git restore --staged file.txt```

2. Сбросить все файлы из staged в untracked - ```git restore --staged .```


### Файл случайно закомитили

1. Окатить все изменения до коммита, который мы укажем - ```git reset --hard <commit hash>```


###  Cлучайно изменили сам файл

1. Удалить из состояние "Changes not staged for commit" - ```git restore file.txt```


## 5 Важные темы


### Какие изменения в файле произошли

```git diff``` - выводит результат сравнения коммитов, modified- и staged-файлов.

1. Посмотреть изменения всех файлов в состоянии 'modified' - ```git diff```

2. Посмотреть изменения всех файлов в состоянии 'staged' - ```git diff --staged```

3. Посмотреть изменения двух коммитов - ```git diff <hash file1> <hash file2>```


### Игнорирование файлов в Git

1. Если нужно, чтобы Git игнорировал какие-то файлы, стоит составить файл .gitignore

2. Посмотреть, что игнорируется, можно с помощью команды - ```git status --ignored```

3. Сам файл '.gitignore' — это обычный файл в репозитории. Его тоже стоит закоммитить.


## 5 Основы работы с ветками Git


### Клонируем репозиторий

1. Rопирует проект с удаленного репозитория на локальный - ```git clone```

Команда git clone автоматически связывает локальный и удалённый репозиторий.


### Выполняем Fork

1. «Форк» позволяет получить точную копию GitHub-репозитория в ваш аккаунт.

2. Копия, которая получена с помощью «форка», полностью независима от оригинального проекта — изменения не будут синхронизированы.


### «Форк» или clone?

Обычно комбинация «форк» + clone используется для внесения изменений в публичные репозитории. 

В этом случае «форк» становится подготовительным этапом перед клонированием чужого репозитория на ваш компьютер.

Если репозиторий приватный или это репозиторий вашей компании, при работе с ним достаточно clone.

### Ветка

Ветка — это последовательность независимых изменений.

Благодаря веткам несколько человек могут работать над одним репозиторием и не мешать друг другу. 

А ещё ветки помогают декомпозировать большую и страшную задачу на маленькие и понятные.

Основная версия проекта хранится в главной ветке main (или master).

1. Чтобы посмотреть, какие в проекте есть ветки и в какой из них вы сейчас находитесь - ```git branch```

2. Создать ветку - ```git branch <название_ветки>```

3. Переместиться на другую ветку - ```git checkout <название_ветки>```

4. Вмето двух действий можно создать и сразу переместиться на новую ветку - ```git checkout -b <название_ветки>```

Ветка указывает на коммит, который сделан в ней последним.

При этом две ветки могут ссылаться на один и тот же коммит — например,

если вы только что создали ветку, но ещё не успели внести в неё коммит.


### Команда git diff

git diff может сравнивать ветки по их названиям. 

1. Вывести разницу между основной веткой и веткой feature/my-feature - ```git diff master feature/my-feature```

Git поддерживает суффикс навигации ~. С его помощью можно сослаться на предыдущие коммиты. 

2. Если вы находитесь в ветке main и хотите вывести разницу между тем коммитом, который был три коммита назад, и текущим - ```git diff master~3 master```


### Объединяем и удаляем ветки

1. Выполнить слияние веток— ```git merge <название_ветки>```

2. Удалить ветку после объединения — ```git branch -D <название_ветки>```


### Что такое конфликт

Если Git не может провести слияние изменений автоматически, он сообщает о конфликте. 

Конфликт — это ситуация, в которой один или несколько человек модифицировали один и тот же файл. 

При этом результаты таких модификаций оказались несовместимы и разобраться в том, какой из вариантов правильный, может только человек.


### Как загрузить локальную ветку в удалённый репозиторий

Имеется основная ветка, мы создаем новую ветку на локальном компьютере

Перед тем как мержить в основную ветку, мы можем отправить новую ветку на гитхаб

Чтобы другие разработчики могли оценить и внести правки перед тем как мои правки попадут в главную ветку.

1. Связать локальный и удаленный репозиторий - ```git remote add origin git@github.com:%ИМЯ_АККАУНТА%/git-branches.git```

2. Загрузить ветку в Гитхаб - ```git push -u origin feature/merge-request```


### Создаём pull request

Нельзя просто внести правки в своей ветке и сразу залить её в основную. 

Сначала ваши коллеги должны убедиться, что предложенные вами изменения логичны и эффективны.

Для этого используют механизм pull request (англ. «запрос на изменения»; буквально: «запрос на подтягивание»). 

В обиходе его обычно так и называют — «пул-реквест», или ещё короче — ПР или PR. 

Алгоритм такой:

1. Вы трудитесь над задачей в своей ветке — например, пишете код новой функциональности.

2. Вы заканчиваете работу, а затем создаёте пул-реквест.

3. Ваши коллеги проверяют, что код выглядит аккуратно и лаконично, а программа работает корректно; также оставляют комментарии.

4. После финального согласования вы заливаете свою ветку в основную.


#### Из чего состоит pull request:

1. Название — краткое описание предлагаемых изменений. Например: Адаптивный заголовок сайта, Замена альбома на галерею и так далее.

2. Описание — развёрнутое описание изменений. Это поле заполнять необязательно, но желательно.

3. Исходная ветка — та, в которой вы работали. Например, feature/merge-request.

4. Целевая ветка — основная ветка проекта, в которую вы хотите внести изменения.

Также у каждого пул-реквеста может быть два исхода:

1. merge (англ. «соединить») — предлагаемые изменения приняты; код вливается в целевую ветку; пул-реквест закрывается.

2. close (англ. «закрыть») — пул-реквест закрывается без слияния изменений.


#### Делаем pull request

После того как новая ветка «запушена» в удалённый репозиторий, можно делать пул-реквест. Существует два способа.

1. При создании новой ветки в удалённом репозитории Git распечатает сообщение. Оно включает ссылку на создание пул-реквеста.

1.1 Останется только скопировать её в адресную строку браузера, заполнить необходимые поля и нажать Create pull request

1.2 Однако такая ссылка появляется только один раз и для новых веток, поэтому иногда приходится идти более сложным путём. 

2. Чтобы создать пул-реквест для любой существующей ветки на GitHub, перейдите на страницу репозитория, а затем выберите вкладку Pull requests в верхней части экрана.


#### Вывод pull request

1. Пул-реквест — это запрос на рассмотрение предлагаемых изменений и часть процесса ревью.

2. Запрос на изменения можно инициировать двумя способами: через ссылку, которую Git выводит после создания ветки, или через интерфейс GitHub.

3. После создания пул-реквеста ваши коллеги сделают ревью — оценят предложенные вами правки и оставят свои комментарии.

4. По результатам ревью ваши правки могут быть приняты в основную ветку проекта или возвращены на доработку.


### Забираем изменения из удалённого репозитория

Представьте, что ваш коллега занимался проектом все выходные, а вы пришли в понедельник и хотите опубликовать свои правки, над которыми поработали ещё в пятницу. 

Однако у проекта уже новая версия — внесённые изменения есть на GitHub и на локальном компьютере коллеги, но не на вашем. 

В этом разделе покажем, как забрать изменения себе.

1. Забрать изменения из удалённого репозитория — ```git pull```

Обычно 'git pull' — это первая команда, которую вводит разработчик, как только открывает код проекта, чтобы начать с ним работать.

Дополнительно git pull и git merge выполняют перед тем, как создать пул-реквест. 


### Порядок отправки ветки в удаленный репозиторий

Обычно: При командной работе, особенно в больших командах, основная ветка часто успевает «убежать» вперёд, пока вы подготавливаете свои изменения. 

Поэтому перед созданием пул-реквеста рекомендуется сначала:

1.0 Перешли в main - ```git checkout main```

1.1 Подтянули новые изменения в main - ```git pull```

2.0 Вернулись в рабочую ветку my-branch - ```git checkout my-branch```

2.1 Влили main в новую ветку my-branch - ```git merge main```

3. Решили все возможные конфликты - 'Решение конфликтов'

4.  Отправили ветку my-branch в удалённый репозиторий - ```git push -u origin my-branch```


## 6 Продвинутая командная работа с Git


### Что такое fast-forward

Две ветки находятся в состоянии fast-forward - если одну из них можно «перемотать» вперёд и она будет содержать те же коммиты, что и другая.

1. при слиянии этих двух веток никак не возможен конфликт;

2. истории этих двух веток не «разошлись»;

3. одна ветка является продолжением другой.

Зачем отключать fast-forward?

Многие проекты отключают fast-forward слияние веток, потому что при нём теряется часть информации. 

Результат выглядит так, как будто в main «просто появились» новые коммиты. 

Если не знать о ветке add-docs, то можно подумать, что такой ветки и не было.

Полноценный коммит слияния сохраняет всю информацию: в нём будет указано, какая именно ветка вливалась в main.

Вывод:

1. Если истории двух веток не «разошлись» и их коммиты выстраиваются в одну цепочку, эти ветки можно объединить в режиме fast-forward.

2. Режим fast-forward можно отключить с помощью флага --no-ff


### Non-fast-forward

Истории двух веток «разошлись». Это значит, что их коммиты уже нельзя выстроить в одну линию.

При слиянии не-fast-forward веток Git создаёт коммит слияния.

Если конфликтов при слиянии нет, команда git merge отработает почти автоматически — только предложит вам ввести сообщение для нового коммита слияния.

1. Чаще всего сообщения к коммитам слияния не редактируют и оставляют «как предложил Git» - ```git merge --no-edit %another_branch%```

Если конфликты всё-таки есть, Git сначала попытается разрешить их автоматически. 

Если не получится, Git предложит вам разрешить их вручную


### Что-то про rebase и git push --force

Форсированный пуш удалит работу Паши — следовательно, такой способ не подходит. 

Скорее всего, Лёша выберет операцию rebase и только после этого «запушит» свои изменения.

Операция rebase может спасти проект из двух разработчиков, которые нечасто «коммитят» изменения. 

Но она не подойдёт, например, для команды из 10 человек:

им придётся тратить больше времени на перебазирование веток, а не на полезные задачи.

! В большинстве систем управления репозиториями (GitHub, GitLab, Bitbucket и подобных) есть специальная настройка «запретить push в main». 

Чаще всего она включена, и прямые git push в main запрещены.


### Модели веток. Простая feature branch модель

*Подходы к работе с ветками* — это правила, которые описывают, когда и для чего создаются ветки, какие в них коммиты и в какой момент происходит слияние веток.

Подходы:

1. Feature branch workflow — простой и самый популярный вариант. 

Если коротко, в нём для каждого нового изменения создаётся новая ветка, которая позже вливается в main с помощью git merge.

2. Git flow — более сложный вариант. Подход похож на feature branch workflow, но в нём создаётся больше веток, а изменения (коммиты) делят на разные типы: 

исправление, новая функциональность и так далее. Разные типы коммитов попадают в разные ветки.

3. Trunk-based — популярный в больших компаниях (таких как Яндекс, Google и прочих) подход, который обещает бо́льшую скорость работы в крупных командах.

Этот подход тоже похож на feature branch workflow. Главное отличие в том, что участники проекта вливают (merge) свой код в основную ветку максимально часто. Например, каждый день.


#### Feature branch workflow

Основные правила:

1. новая функциональность или исправление — новая ветка;

2. когда код в feature-ветке готов, он вливается в main;

3. в main всегда рабочая версия без «недоделок».

Преимущества:

1. простая модель;

2. позволяет работать с Git в команде без лишних технических сложностей.


### Что- то про Pull request и code review

1. Во многих командах пул-реквест — это основной путь, по которому изменения или исправления попадают в основную ветку проекта.

2. Важный этап пул-реквеста — ревью. В ходе ревью коллега оценит правки и предложит доработки, если они нужны.

Когда всё будет готово, ревьюер примет («апрувнет») изменения, затем их можно будет интегрировать в main.


### Работа с PR: практика

1. Автор создаёт пул-реквест.

2. Ревьюер просматривает изменения и предлагает правки, если они необходимы.

3. Автор вносит исправления по комментариям ревьюера.

4. Второй и третий пункты могут повториться!

5. Если ревьюера всё устраивает, он одобряет («апрувит») пул-реквест.

6. Вуаля! Теперь автор или ревьюер могут влить изменения в основную ветку.

### Разрешение конфликта вручную и через vimdiff

Конфликты — это ситуация, в которой две ветки или более изменяют один и тот же файл в разных местах и пытаются объединиться в одну ветку.

При возникновении конфликта Git добавит в файлы маркеры конфликтов. 

Вы можете разрешить конфликт вручную: достаточно удалить маркеры и принять правильные изменения.

Для разрешения конфликтов вы также можете использовать vimdiff — он доступен по умолчанию.

1. Разрешение конфликтов вручную — долгий и трудоёмкий процесс. 

2. Чтобы упростить эту задачу, можно использовать инструменты слияния (англ. mergetool).


### Что делать, если основная ветка «убежала» вперёд в процессе ревью

Разрешить конфликт можно так:

1. Перейти в ветку main.

2. Загрузить новые изменения из неё с помощью git pull. При этом вы также загрузите ветку вашего коллеги.

3. Снова перейти в вашу ветку feature/my-new-awesome-code.

4. Выполнить git merge main и разрешить конфликт локально. В результате будет создан локальный коммит слияния.

5. Отправить изменения из вашей ветки в репозиторий с помощью git push. Так коммит слияния попадёт в удалённый репозиторий и в пул-реквест.

Комментарий: GitHub предоставляет графический интерфейс для решения конфликтов, хотя большинство пользователей предпочитают разрешать конфликты локально.